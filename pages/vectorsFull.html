<!DOCTYPE html>
<html lang="en">

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vector Graphing</title>
  <link href="https://fonts.googleapis.com/css?family=Encode+Sans:400,700" rel="stylesheet">
  <!-- <link href="../stylesheets/main.css" rel="stylesheet" /> -->
  <!-- <link href="../stylesheets/vectors.css?v=1.0" rel="stylesheet" /> -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="icon" href="../siteimages/favicon.png">
  <!-- <script src="../scripts/build-page.js" type="module"></script> -->
  <style>
    header {
      padding: 0em;
      color: white;
      clear: left;
      text-align: center;
      width: 100%;
      transition: width 0.5s;
      background-color: rgb(255, 255, 255);
    }

    body {
      margin: 0;
    }

    #darkmode {
      width: 4%;
      height: auto;
      position: fixed;
      z-index: 10;
      bottom: 15px;
      right: 15px;
      cursor: pointer
    }

    #homeHead a:link {
      text-decoration: none;
    }

    #homeHead a:visited {
      color: white;
      text-decoration: none;
    }

    #homeHead a:hover {
      text-decoration: none;
      text-decoration-color: white;
    }

    #hamMenu a:link {
      text-decoration: none;
    }

    #hamMenu a:hover {
      text-decoration: none;
      text-decoration-color: white;
    }

    #menuTitle {
      cursor: pointer;
    }

    /* #menuTitle:hover {
  background-color:rgb(0,0,125);
} */

    /* classes */

    /* Ham */

    .secretDropdownContainer {
      position: relative;
      display: inline-block;
      width: 100%;
    }

    .upperham:hover {
      position: relative;
      background-color: rgba(0, 0, 125, 1);
    }

    .upperHam {
      margin: auto;
      padding: 0.5em 1em 0.5em 24px;
      width: 100%;
      position: relative;
      background-color: rgba(0, 0, 200, 1);
      border: none;
      outline: none;
      font-size: 1.4em;
      font-family: Encode Sans;
      font-weight: bold;
      color: white;
      cursor: pointer;
    }

    .upperHam.active {
      background-color: rgba(25, 25, 175, 1);
    }

    .lowerHam {
      display: none;
      position: relative;
      width: 100%;
      margin: auto;
      overflow: hidden;
      background-color: white;
      cursor: pointer;
      transition: max-height 0.2s ease-out;
      transition: 0.4s;
    }

    .lowerHam a {
      display: block;
      padding: 0.7em;
      overflow: hidden;
      font-size: 1.3em;
      font-family: Encode Sans;
      font-weight: bold;
      color: rgb(0, 0, 200);
      cursor: pointer;
      text-align: center;
    }

    .lowerHam a:hover {
      color: #ffbb00;
    }

    /* Div IDs */

    #main {
      height: calc(100% - 64px);
      transition: all 0.5s ease;
      margin-top: calc(64px + 0.5em);
    }

    /* Menu */

    #homeHead {
      background-color: inherit;
      border-bottom: 0.5em rgb(0, 0, 200) solid;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 5000;
      width: inherit;
    }

    #homeHead h1 {
      margin: auto;
      line-height: 2em;
      font-size: 2em;
      font-family: Encode Sans;
      color: rgb(0, 0, 200);
    }

    #hamMenu {
      width: 0px;
      height: 100%;
      position: fixed;
      top: 0px;
      right: 0px;
      z-index: 10000;
      overflow-x: hidden;
      transition: 0.5s;
      background-color: rgb(0, 0, 200);
      text-align: right;
      color: rgb(0, 0, 200);
    }

    #hamMenu h1 {
      margin: auto;
      line-height: 2em;
      font-size: 2em;
      font-family: Encode Sans;
      color: rgb(255, 255, 255);
    }


    #hamMenuText {
      line-height: 2em;
      text-align: right;
      color: white;
    }

    #gamesMenuBase {
      display: none;
    }

    #sitesMenuBase {
      display: none;
    }

    /* HAM MENU & HEADER COMPLETE */

    #controls {
      font-family: monospace;
      width: 220px;
      height: 100%;
      border-right: 2px solid #000000;
      float: left;
      z-index: 10;
      overflow-y: hidden;
    }

    #controls h2 {
      text-align: center;
      border-bottom: 2px solid #000000;
      margin-bottom: 0;
    }

    #canvasBox canvas {
      float: inherit;
    }

    #calculations>p {
      color: #666;
      text-align: center;
      padding: 1em;
      margin: 0;
    }

    #vectorTabs {
      overflow-x: hidden;
      overflow-y: scroll;
      border-bottom: 1px solid #000000;
    }

    #vectorCreator .vectorColour {
      color: #666;
      line-height: 40px;
    }

    .calculation {
      padding: 10px;
      display: grid;
      border-bottom: 1px solid #000000;
    }

    .calculation p {
      margin: 0.25em 0;
    }

    .calculation p.clickable {
      color: #0034f1;
      text-decoration: underline;
      cursor: pointer;
    }

    .calculation h3 {
      margin: 0;
      font-size: 14px;
    }

    .calculation .center {
      text-align: center;
      margin: auto;
      font-size: 18px;
      margin-top: 0.25em;
    }

    .calculation .singleLine .vectorDropArea {
      margin-right: 6px;
    }

    .calculation .singleLine h3 {
      margin-top: 1px;
    }

    .calculation .vectorDropArea {
      border: 2px dotted #CCC;
      width: 10px;
      height: 10px;
      float: left;
      padding: 3px;
      border-radius: 100px;
      color: #FFF;
      font-size: 10px;
      text-align: center;
    }

    .calculation .operator {
      width: 18px;
      height: 18px;
      float: left;
    }

    .closeInfoTab {
      margin-top: -1em;
      cursor: pointer;
      color: #aaaaaa;
    }

    .infoTab {
      display: table;
      width: 210px;
      padding: 1em 10px 1em 0em;
      border-bottom: 1px solid #000000;
    }

    .infoTab>.vectorColour {
      width: 10px;
      height: 10px;
      float: left;
      margin-left: 4px;
      padding: 3px;
      border-radius: 100px;
      border: 2px solid #FFFFFF;
      color: #FFF;
      font-size: 10px;
      text-align: center;
      cursor: pointer;
    }

    .infoTab>.coordinates {
      margin-left: 0.5em;
      float: left;
    }

    .infoTab>.coordinates>p {
      margin: 0;
    }

    .infoTab>.coordinates input {
      width: 2em;
      border: none;
      outline: none;
      border-bottom: 1px solid #444444;
      font-family: monospace;
      text-align: center;
    }

    .scrollArea {
      width: 14px;
    }
  </style>
</head>

<body style="margin:0" onresize="doResize = true">

  <div id="loadingScreen">
    <img src="../siteimages/logo.svg" alt="colestanley.ca">
  </div>

  <div id="main">

    <header id="header">
      <div id="homeHead">
        <div style="width: 10%; z-index: 10000; float: left; padding: 1%;"></div>
        <div style="display: inline-block; position: absolute; left: calc(50% - 109px); z-index: 6;"><a>
            <h1 style="text-align: center; min-height: 64px;">Vector Graphing</h1>
          </a></div>
        <div style="height: 44px; float: right; padding: 10;"></div>
      </div>
    </header>

    <div id="hamMenu" style="overflow-y: hidden; width: 0%; min-width: 0px;">
      <div style="background-color: rgb(0, 0, 200); height: 64px;">
        <h1 style="text-align: center;" id="menuTitle" onclick="closeHam()">MENU</h1>
      </div>
      <div id="gamesMenuItem" class="secretDropdownContainer" onclick="buttons(0)"><button
          class="upperHam">Games</button>
        <div id="menuItem2" class="lowerHam" style="display: none;"><a
            href="https://drive.google.com/open?id=1MlW4gyXsaFHNxZFwPfi4f-45UrGY9k6w">Daydream</a></div>
        <div id="menuItem3" class="lowerHam" style="display: none;"><a
            href="https://drive.google.com/open?id=1YBHmeOboxp6Vb6JGg8EoS4n8ri_PbSkK">Tic Tac Toe AI</a></div>
        <div id="menuItem4" class="lowerHam" style="display: none;"><a href="../games/wires.html">Broken Wires</a></div>
        <div id="menuItem5" class="lowerHam" style="display: none;"><a href="../games/escape.html">Starship Escape</a>
        </div>
        <div id="menuItem6" class="lowerHam" style="display: none;"><a
            href="https://drive.google.com/open?id=1nYmU7NLD6Ip7YVuD8M3xtqJ0o6QF6mJL">The Kitten and the Crypt</a></div>
        <div id="menuItem7" class="lowerHam" style="display: none;"><a href="../games/luigi.html">Mario 1-1</a></div>
      </div>
      <div id="sitesMenuItem" class="secretDropdownContainer" onclick="buttons(1)"><button class="upperHam">Gadgets
          &amp; Tools</button>
        <div id="menuItem8" class="lowerHam" style="display: none;"><a href="../pages/dice.html">Dice Roller</a></div>
        <div id="menuItem9" class="lowerHam" style="display: none;"><a href="../pages/emwaves.html">EM Wave Animator</a>
        </div>
        <div id="menuItem10" class="lowerHam" style="display: none;"><a href="../pages/npcs.html">D&amp;D 5e NPC
            Generator</a></div>
        <div id="menuItem11" class="lowerHam" style="display: none;"><a href="../pages/calculator.html"
            style="color: #7b9dfb">Algebra Calculator</a></div>
        <div id="menuItem12" class="lowerHam" style="display: none;"><a href="../pages/vectors.html"
            style="color: #7b9dfb">Vector Graphing</a></div>
      </div><img
        style="margin: auto; margin-top: 33%; display: block; width: 33%; position: relative; bottom: 0px; cursor: pointer;"
        src="../siteimages/closebutton.png" onclick="closeHam()"><a href="../index.html"><img
          style="margin: auto; margin-top: 33%; display: block; width: 33%; position: relative; bottom: 0px; cursor: pointer;"
          src="../siteimages/home.png"></a>
    </div>

    <div style="display: block">
      <div id="controls">
        <div id="tabs">
          <h2>Vectors</h2>
          <div id="vectorTabs">
            <div id="existingVectors">
            </div>
            <div id="userInput">
              <div class="infoTab" id="vectorCreator" style="border-bottom: none">
                <div onclick="createVector()" class="vectorColour"
                  style="background-color: #FFF; border: 2px solid #CCC;">
                  create
                </div>
                <div class="coordinates">
                  <p><i> x: <input></input> y: <input></input> z: <input></input> </i></p>
                </div>
              </div>
            </div>
          </div>
          <div id="calculations">
            <h2>Calculations</h2>
            <div class="calculation" id="magnitude">
              <div class="singleLine">
                <div ondrop="dragDrop(event, this)" ondragover="dragAllowDrop(event)" class="vectorDropArea"></div>
                <h3>Magnitude: </h3>
                <p id="magnitudeValue"></p>
              </div>
            </div>
            <div class="calculation" id="projection">
              <h3>Projections</h3>
              <div class="center">
                <div ondrop="dragDrop(event, this)" ondragover="dragAllowDrop(event)" class="vectorDropArea"></div>
                <div class="operator">&#x2913</div>
                <div ondrop="dragDrop(event, this)" ondragover="dragAllowDrop(event)" class="vectorDropArea"></div>
              </div>
              <p>Scalar Projection:</p>
              <p onclick="calculationInput('vectorProjection')">Calculate Vector Projection</p>
            </div>
            <div class="calculation" id="dot">
              <h3>Dot Product</h3>
              <div class="center">
                <div ondrop="dragDrop(event, this)" ondragover="dragAllowDrop(event)" class="vectorDropArea"></div>
                <div class="operator">&#x2022</div>
                <div ondrop="dragDrop(event, this)" ondragover="dragAllowDrop(event)" class="vectorDropArea"></div>
              </div>
            </div>
            <div class="calculation" id="cross">
              <h3>Cross Product</h3>
              <div class="center">
                <div ondrop="dragDrop(event, this)" ondragover="dragAllowDrop(event)" class="vectorDropArea"></div>
                <div class="operator">&#x00d7</div>
                <div ondrop="dragDrop(event, this)" ondragover="dragAllowDrop(event)" class="vectorDropArea"></div>
              </div>
              <p onclick="calculationInput('cross')">Calculate</p>
            </div>
            <div class="calculation" id="tsp">
              <h3>Triple Scalar Product</h3>
              <div class="center">
                <div ondrop="dragDrop(event, this)" ondragover="dragAllowDrop(event)" class="vectorDropArea"></div>
                <div class="operator">&#x2022</div>
                <div class="operator">(</div>
                <div ondrop="dragDrop(event, this)" ondragover="dragAllowDrop(event)" class="vectorDropArea"></div>
                <div class="operator">&#x00d7</div>
                <div ondrop="dragDrop(event, this)" ondragover="dragAllowDrop(event)" class="vectorDropArea"></div>
                <div class="operator">)</div>
              </div>
              <p>&#x2003</p> <!-- empty character -->
            </div>
            <p>drag and drop the circles</p>
          </div>
        </div>
        <div id="scrollArea"></div>
      </div>
    </div>

    <div id="canvasBox">
    </div>

    <!--  -->

  </div>

  <script>
    /**
 * EM Wave Generator
 * 
 * This program animates an em wave.
 * 
 * Cole Stanley
 * 
 * Start Date: May 23rd, 2020
 * 
 * TODO
 * 
 * 
 * DONE
 * - Scales
 * - magnitude in "calculations"
 * - cross product
 * - z-axis functionality
 * - graph
 * - controls bar
 * - user-driven vector creation
 * - show/hide individual vectors
 * - dot product in "calculations"
 * - projections
 * - vector and associated infoTab deletion
 * - triple scalar product
 * - decent changeable scale
 */

    function betterCreateAttr(type, value) {
      var attr = document.createAttribute(type);
      attr.value = value;
      return attr;
    }

    const ARROW = {
      w: 5,
      h: 8
    }

    const COLOURS = ["#FF0000", "#00CC00", "#0000FF", "#FF00FF", "#00CCCC", "#ff4000", "#40ff00", "#00eebe", "#8000ff", "#009926", "#004d99", "#1a0066", "#660066", "#00664d", "#336600", "#663300"];

    // Program-specific variables

    var origin = {
      x: 0,
      y: 0
    };

    var vectors = [];

    // debug

    const MINSTARTVECTORS = 1;
    const MAXSTARTVECTORS = 3;
    const MAXSTARTVECTORLENGTH = 10;

    /**
     * The z axis
     * 
     * @param angle: The angle between the x axis and the z axis, in RADIANS
     */

    var zAxis = {
      angle: (16) / 180 * Math.PI,
      components: {
        x: 0,
        y: 0
      } // defined in init()
    };

    var scaleInterval = 5; // number at which to mark the scale
    var numTicks = 40;
    var unitLength; // pixels per unit
    var tickLength = 8;
    var drawnTicks = 1; // every *drawnticks*th tick will be drawn
    var scaleColour = "#999999";
    var altScaleColour = "#000000";

    var currentDraggedObject;

    var infoTabs = 0;

    var showScaleNumbers = true;

    // General Canvas Variables

    const CANVAS_WIDTH_PERCENTAGE = 0.8;

    var animator;
    var now = Date.now();
    var usePointer = false;

    var switchState = 0; // 0 = none; 1 = white; -1 = black;
    var bgC = 255;
    var bgSwitchTime = 0;

    var doResize = false;
    var lastResize = now; //causes an instant restart, but it fixes the canvas size
    var lastMenuSize = document.getElementById("hamMenu").getBoundingClientRect().width;

    var consolesLogged = false;

    var myCanvas = {
      canvas: document.createElement("canvas"),
      start: function () {
        resizeCanvas(); // centralizes canvas sizing
        this.canvas.style.backgroundColor = "white";
        this.canvas.style.transition = "all 0.5s linear";
        this.canvas.setAttributeNode(
          betterCreateAttr("oncontextmenu", "return false;")
        );

        this.isClicking = false;
        this.recentClick = false;
        this.clickLeft = true;

        this.context = this.canvas.getContext("2d", {
          alpha: false
        });

        document.getElementById("canvasBox").appendChild(this.canvas);

        window.addEventListener("keydown", function (e) {
          myCanvas.keys = myCanvas.keys || [];
          myCanvas.keys[e.keyCode] = true;
        });
        window.addEventListener("keyup", function (e) {
          myCanvas.keys[e.keyCode] = false;
        });
        myCanvas.canvas.addEventListener(
          "click",
          function (evt) {
            canvasArea = myCanvas.canvas.getBoundingClientRect();
            myCanvas.mouseX = evt.clientX - canvasArea.left;
            myCanvas.mouseY = evt.clientY - canvasArea.top;
            myCanvas.clickTime = now;
            myCanvas.recentClick = true;
            myCanvas.clickLeft = true;
          },
          false
        );
        myCanvas.canvas.addEventListener(
          "touchend",
          function (evt) {
            canvasArea = myCanvas.canvas.getBoundingClientRect();
            myCanvas.mouseX = evt.clientX - canvasArea.left;
            myCanvas.mouseY = evt.clientY - canvasArea.top;
            myCanvas.clickTime = now;
            myCanvas.recentClick = true;
            myCanvas.clickLeft = true;
            mobile = true;
          },
          false
        );
        myCanvas.canvas.addEventListener(
          "mousemove",
          function (evt) {
            canvasArea = myCanvas.canvas.getBoundingClientRect();
            myCanvas.mouseX = evt.clientX - canvasArea.left;
            myCanvas.mouseY = evt.clientY - canvasArea.top;
          },
          false
        );
        myCanvas.canvas.addEventListener(
          "contextmenu",
          function (evt) {
            canvasArea = myCanvas.canvas.getBoundingClientRect();
            myCanvas.mouseX = evt.clientX - canvasArea.left;
            myCanvas.mouseY = evt.clientY - canvasArea.top;
            myCanvas.clickTime = now;
            myCanvas.recentClick = true;
            myCanvas.clickLeft = false;
          },
          false
        );
      },

      clear: function () {
        this.drawRect(
          0,
          0,
          this.canvas.width,
          this.canvas.height,
          "rgb(" + bgC + "," + bgC + "," + bgC + ")"
        );
      },

      /**
       * Draws an image to the canvas
       * @param {Element} img The image element
       * @param {Number} x The top-left x-coordinate of the image.
       * @param {Number} y The top-left y-coordinate of the image.
       * @param {Number} w (optional) The width of the image.
       * @param {Number} h (optional) The height of the image.
       */

      drawImg: function (img, x, y, w, h) {
        if (h === null) this.context.drawImage(img, x, y);
        else this.context.drawImage(img, x, y, w, h);
      },

      /**
       * Draws a line to the canvas between two points
       * @param {Number} x1 The x coordinate of the start point
       * @param {Number} y1 The y coordinate of the start point
       * @param {Number} x2 The x coordinate of the end point
       * @param {Number} y2 The y coordinate of the end point
       * @param {String} newColour The colour of the line.  If left null, the colour of the last line drawn will be used.
       * @param {Number} newWidth The width of the line.  If left null, the width of the last line drawn will be used.
       */

      drawLine: function (x1, y1, x2, y2, newColour, newWidth) {
        if (typeof newColour !== "undefined")
          this.context.strokeStyle = newColour;
        if (typeof newWidth !== "undefined")
          this.context.strokeStyle = newWidth;

        this.context.beginPath();
        this.context.moveTo(Math.round(x1), Math.round(y1));
        this.context.lineTo(Math.round(x2), Math.round(y2));
        this.context.stroke();
      },

      /**
       * Draws a rectangle to the canvas
       * @param {*} x The top-left x-coordinate of the rectangle.
       * @param {*} y The top-left y-coordinate of the rectangle.
       * @param {*} w The width of the rectangle.
       * @param {*} h The height of the rectangle.
       * @param {*} colour The colour of the rectangle.  If left null, the colour of the last line drawn will be used.
       */

      drawRect: function (x, y, w, h, colour, filled) {
        this.context.fillStyle = colour;
        if (filled === false)
          this.context.strokeRect(x, y, w, h);
        else
          this.context.fillRect(x, y, w, h);
      },

      /**
       * Draws text to the canvas
       * @param {*} text The text to be drawn
       * @param {*} x The x-coordinate
       * @param {*} y The y-coordinate
       * @param {*} colour The text's colour
       * @param {*} centered Whether to center the text upon the x and y coordinate
       * @param {*} size pt of font
       * @param {*} type bold?
       */

      drawText: function (text, x, y, colour, centered, size, type) {
        this.context.fillStyle = colour;
        if (type !== null) this.context.font = size + "px " + type;
        if (centered) this.context.textAlign = "center";
        else this.context.textAlign = "left";
        this.context.fillText(text, x, y);
      },

      /**
       * Draws an isoceles triangle to the canvas
       * @param {Number} x 
       * @param {Number} y 
       * @param {Number} w 
       * @param {Number} h
       * @param {Boolean} center Centers the triangle around (x, y)
       * @param {Number} angle (DEGREES) The angle from vertical at which to draw the triangle.  Only works correctly if center == true.
       */

      drawTriangle: function (x, y, w, h, colour, center, angle) {
        let canvas = this.context;
        angle = toRadians(angle);

        canvas.beginPath();
        canvas.fillStyle = colour;
        canvas.strokeStyle = colour;

        if (center) {
          let a = { x: x - w / 2, y: y + h / 2 };
          let b = { x: x, y: y - h / 2 };
          let c = { x: x + w / 2, y: y + h / 2 };

          if (!isNaN(angle) && angle !== 0) {
            canvas.translate(x, y);
            canvas.rotate(
              angle
            );

            canvas.moveTo(a.x - x, a.y - y);
            canvas.lineTo(b.x - x, b.y - y);
            canvas.lineTo(c.x - x, c.y - y);
            canvas.lineTo(a.x - x, a.y - y);

            canvas.rotate(
              -angle
            );
            canvas.translate(-x, -y);
          } else {
            canvas.moveTo(a.x, a.y);
            canvas.lineTo(b.x, b.y);
            canvas.lineTo(c.x, c.y);
            canvas.lineTo(a.x, a.y);
          }
          canvas.fill();
        } else { // x,y = top left of the triangle
          canvas.moveTo(x, y + h);
          canvas.lineTo(x + w / 2, y);
          canvas.lineTo(x + w, y + h);
          canvas.lineTo(x, y + h);
          canvas.fill();
        }
      },

      /**
       * Stops the animation loop of the canvas
       */

      stop: function () {
        window.cancelAnimationFrame(animator);
      }
    };

    function init(firstTime, fullRestart) {
      if (firstTime) console.log("initializing");
      else console.log("(re)initializing");

      myCanvas.start();
      document.documentElement.style.overflow = "hidden";

      // reset origin position, zAxis

      origin.x = myCanvas.canvas.width / 2;
      origin.y = myCanvas.canvas.height / 2;

      zAxis.components.x = myCanvas.canvas.width / 2;
      zAxis.components.y = (myCanvas.canvas.width / 2) * Math.tan(zAxis.angle);

      // reset vectors array

      if (fullRestart) {
        setScale(40);
        vectors = [];
        infoTabs = 0;
        document.getElementById("existingVectors").innerHTML = "";


        for (let i = 0; i < Math.round(Math.random() * (MAXSTARTVECTORS - MINSTARTVECTORS)) + MINSTARTVECTORS; i++)
          newVector(0, 0, 0, Math.round(Math.random() * MAXSTARTVECTORLENGTH * 2) - MAXSTARTVECTORLENGTH, Math.round(Math.random() * MAXSTARTVECTORLENGTH * 2) - MAXSTARTVECTORLENGTH, Math.round(Math.random() * MAXSTARTVECTORLENGTH * 2) - MAXSTARTVECTORLENGTH);
      }

      for (v in vectors) {
        vectors[v].setCosmetics();
      }

      if (firstTime) {
        // creating wheel listener

        let multiplier = 1.1;

        window.addEventListener("wheel", function (e) {
          if (e.deltaY < 0)
            setScale(numTicks / multiplier);
          else if (e.deltaY > 0)
            setScale(numTicks * multiplier);
        });

        window.requestAnimationFrame(main);
      }
    }

    function main() {
      // resets

      now = Date.now();

      if (doResize) {
        resizeCanvas();
        doResize = false;
        lastResize = now + 50;
      } else if (lastMenuSize !== document.getElementById("hamMenu").getBoundingClientRect().width) {
        resizeCanvas();
        lastMenuSize = document.getElementById("hamMenu").getBoundingClientRect().width;
        init(false, false);
      }

      if (now > lastResize && lastResize > 0) {
        init(false, false);
        lastResize = -1;
      }

      // step 4: draw

      redraw();

      myCanvas.canvas.style.backgroundColor = document.getElementById(
        "main"
      ).style.backgroundColor;

      let c; // canvas

      switch (switchState) {
        case 1:
          if (bgC === 255) {
            switchState = 0;
            break;
          } else c = Math.floor((now - bgSwitchTime) / (1.96078431373 * 1));
          if (c > 255) c = 255;
          bgC = c;
          break;
        case -1:
          if (bgC === 0) {
            switchState = 0;
            break;
          } else c = 255 - Math.floor((now - bgSwitchTime) / (1.96078431373 * 1));
          if (c < 0) c = 0;
          bgC = c;
          break;
      }

      // step 5: input

      getIn();

      // step 6: work

      // canvas stuff

      if (usePointer) myCanvas.canvas.style.cursor = "pointer";
      else myCanvas.canvas.style.cursor = "default";

      myCanvas.recentClick = false;
      usePointer = false;
      consolesLogged = true;
      animator = window.requestAnimationFrame(main);
    }

    /**
     * Builds an information element and appends it to the screen
     * 
     * @param vector The vector to build the info element for
     */

    function buildInfo(vector) {
      // element creation, filling
      let info = document.createElement("div");
      info.setAttributeNode(betterCreateAttr("class", "infoTab"));
      info.setAttributeNode(betterCreateAttr("id", "infoTab" + infoTabs));

      let inner = "<div class='vectorColour' draggable = 'true' onclick='setVectorVisibility(this.parentElement)' ondragstart='dragStart(this.parentElement)' \
  style = 'background-color: " + vector.colour + "; border: 2px solid" + vector.colour + "' > \
  \
  " + infoTabs + "</div > \
  <div class='coordinates'>\
  <p> x: <input onblur='updateVectors()'></input> y: <input onblur='updateVectors()'></input> z: <input onblur='updateVectors()'></input> </p>   \
  </div>\
  <div class = 'closeInfoTab' onclick = 'closeInfoTab(this.parentElement)'>x</div> ";

      info.innerHTML = inner;

      // set values of input elements
      for (let i = 0; i < info.children[1].children[0].children.length; i++) {
        info.children[1].children[0].children[i].value = Object.entries(vector.components)[i][1];
      }

      document.getElementById("existingVectors").appendChild(info); // append to screen

      vector.infoTab = infoTabs;
      infoTabs++;
    }

    /**
     * Gets user input for the cross product, makes a cross product vector
     * 
     * @param type The type of calculation being inputted
     */

    function calculationInput(type) {
      let factors, a, b;
      switch (type) {
        case 'cross':
          factors = [document.getElementById(type).children[1].children[0], document.getElementById(type).children[1].children[2]]; // get vectorColour elements
          a = vectors[factors[0].id];
          b = vectors[factors[1].id];

          makeCrossProduct(a, b, true);
          break;
        case 'dot':
          factors = [document.getElementById(type).children[1].children[0], document.getElementById(type).children[1].children[2]]; // get vectorColour elements
          a = vectors[factors[0].id];
          b = vectors[factors[1].id];

          if (a == undefined || b == undefined)
            break;

          document.getElementById(type).children[0].innerHTML = "Dot Product: " + getDotProduct(a, b) + " units"; // change h3 tag
          break;
        case 'magnitude':
          let v = vectors[document.getElementById(type).children[0].children[0].id];

          document.getElementById(type).children[0].children[1].innerHTML = "Magnitude: <br>" + Math.round(v.magnitude * 1000) / 1000 + " units";
          break;
        case "scalarProjection":
          factors = [document.getElementById("projection").children[1].children[0], document.getElementById("projection").children[1].children[2]]; // get vectorColour elements
          a = vectors[factors[0].id];
          b = vectors[factors[1].id];

          document.getElementById("projection").children[2].innerHTML = "Scalar Projection: <br>" + Math.round(getScalarProjection(a, b) * 1000) / 1000 + " units";
          break;
        case "tsp":
          factors = [document.getElementById("tsp").children[1].children[0], document.getElementById("tsp").children[1].children[3], document.getElementById("tsp").children[1].children[5]]; // get vectorColour elements
          a = vectors[factors[0].id];
          b = vectors[factors[1].id];
          c = vectors[factors[2].id];

          let cross = makeCrossProduct(b, c, false);
          document.getElementById(type).children[2].innerHTML = getDotProduct(a, cross) + " units"; // change h3 tag

          break;
        case "vectorProjection":
          factors = [document.getElementById("projection").children[1].children[0], document.getElementById("projection").children[1].children[2]]; // get vectorColour elements
          a = vectors[factors[0].id];
          b = vectors[factors[1].id];

          makeVectorProjection(a, b);
          break;
        default:
          console.log("unset calculation type");
      }
    }

    /**
     * Closes an infoTab
     * 
     * @param {Element} tab InfoTab element 
     */

    function closeInfoTab(tab) {
      tab.style.display = "none";
      setVectorVisibility(tab);
    }

    /**
     * Takes input from the vectorCreator element
     */

    function createVector() {
      let data = document.getElementById("vectorCreator").children[1].children[0].children[0].children;

      for (let i = 0; i < data.length; i++) {
        if (data[i].value == "" || isNaN(parseInt(data[i].value))) {
          console.log("invalid input");
          return;
        }
      }

      newVector(0, 0, 0, data[0].value, data[1].value, data[2].value, COLOURS[infoTabs % COLOURS.length], 1);
      data[0].value = "";
      data[1].value = "";
      data[2].value = "";
    }

    /**
     * Draws the arrow with its tip at the end of a Vector
     * @param {Vector} vector The Vector to cap
     */

    function drawArrow(vector) {
      let tip = { x: vector.cosmeticOrigin.x + vector.cosmeticComponents.x, y: vector.cosmeticOrigin.y + vector.cosmeticComponents.y }; // the top point of the triangle (when upright)
      let triangle = { // the arrow
        x: tip.x - (ARROW.h / 2) * Math.sin(vector.angle2d * Math.PI / 180),
        y: tip.y + (ARROW.h / 2) * Math.cos(vector.angle2d * Math.PI / 180),
        w: ARROW.w,
        h: ARROW.h,
        a: vector.angle2d
      };

      // if vector is TINY, don't draw arrow

      if (Math.abs((ARROW.w / 2) * Math.sin(vector.angle2d * Math.PI / 180) * 1) > Math.abs(pythagorean(vector.cosmeticComponents.x, vector.cosmeticComponents.y, null))
        || Math.abs((ARROW.h / 2) * Math.sin(vector.angle2d * Math.PI / 180) * 1) > Math.abs(pythagorean(vector.cosmeticComponents.x, vector.cosmeticComponents.y, null)))
        return;

      // if (vector == vectors[0]) console.log((ARROW.h / 2) * Math.sin(vector.angle2d * Math.PI / 180) * 2, vector.cosmeticComponents.x);

      myCanvas.drawTriangle(triangle.x, triangle.y, triangle.w, triangle.h, vector.colour, true, triangle.a);
    }

    /**
     * Important function - among many things, it gives the cursor its appearance when hovering over the drop area 
     * @param {*} evt 
     */

    function dragAllowDrop(evt) {
      evt.preventDefault();
    }

    /**
     * "Drops" a vectorColour element into its slot
     * @param {Event} event The drop event
     * @param {Element} dropZone The vector slot
     */

    function dragDrop(event, dropZone) {
      // dropping the vectorColour

      dropZone.style.backgroundColor = currentDraggedObject.children[0].style.backgroundColor;
      dropZone.id = currentDraggedObject.id.substring(7);

      dropZone.innerHTML = currentDraggedObject.children[0].innerHTML;

      switch (dropZone.parentElement.parentElement.id) {
        case "dot":
        case "magnitude":
          calculationInput(dropZone.parentElement.parentElement.id);
          break;
        case "cross":
          // if both dropzones are filled
          if (window.getComputedStyle(dropZone.parentElement.children[0]).backgroundColor != "rgba(0, 0, 0, 0)" && window.getComputedStyle(dropZone.parentElement.children[2]).backgroundColor != "rgba(0, 0, 0, 0)") {
            dropZone.parentElement.parentElement.children[2].className = "clickable"; // calculate
          }
          break;
        case "projection":
          // if both dropzones are filled
          if (window.getComputedStyle(dropZone.parentElement.children[0]).backgroundColor != "rgba(0, 0, 0, 0)" && window.getComputedStyle(dropZone.parentElement.children[2]).backgroundColor != "rgba(0, 0, 0, 0)") {
            dropZone.parentElement.parentElement.children[3].className = "clickable"; // calculate
            calculationInput("scalarProjection");
          }
          break;
        case "tsp":
          // if all three dropzones are filled
          if (window.getComputedStyle(dropZone.parentElement.children[0]).backgroundColor != "rgba(0, 0, 0, 0)"
            && window.getComputedStyle(dropZone.parentElement.children[3]).backgroundColor != "rgba(0, 0, 0, 0)"
            && window.getComputedStyle(dropZone.parentElement.children[5]).backgroundColor != "rgba(0, 0, 0, 0)") {
            calculationInput("tsp");
          }
          break;
      }
    }

    /**
     * Registers a vector colour as being dragged
     */

    function dragStart(el) {
      currentDraggedObject = el;
    }

    /**
     * Draws the scale to the axes
     */

    function drawScale() {

      // x axis

      for (let x = origin.x + unitLength; x < myCanvas.canvas.width; x += unitLength) { // positive  
        if ((x - origin.x) % (unitLength * scaleInterval) == 0 && x !== origin.x) {
          if (showScaleNumbers)
            myCanvas.drawText((x - origin.x) / unitLength, x, origin.y - tickLength, "black", true, 14, "bold");
          myCanvas.drawLine(x, origin.y - tickLength / 2, x, origin.y + tickLength / 2, altScaleColour, 1);
        } else if (((x - origin.x) / unitLength) % drawnTicks === 0)
          myCanvas.drawLine(x, origin.y - tickLength / 2, x, origin.y + tickLength / 2, scaleColour, 1);
      }

      for (let x = origin.x - unitLength; x > 0; x -= unitLength) { // negative
        if ((x - origin.x) % (unitLength * scaleInterval) == 0 && x !== origin.x) {
          if (showScaleNumbers)
            myCanvas.drawText((x - origin.x) / unitLength, x, origin.y - tickLength, "black", true, 14, "bold");
          myCanvas.drawLine(x, origin.y - tickLength / 2, x, origin.y + tickLength / 2, altScaleColour, 1);
        } else if (((x - origin.x) / unitLength) % drawnTicks === 0)
          myCanvas.drawLine(x, origin.y - tickLength / 2, x, origin.y + tickLength / 2, scaleColour, 1);
      }

      // y axis

      for (let y = origin.y + unitLength; y < myCanvas.canvas.height; y += unitLength) { // negative
        if ((y - origin.y) % (unitLength * scaleInterval) == 0 && y !== origin.y) {
          if (showScaleNumbers)
            myCanvas.drawText(-(y - origin.y) / unitLength, origin.x + tickLength * 2 + 4, y + 4, "black", true, 14, "bold");
          myCanvas.drawLine(origin.x - tickLength / 2, y, origin.x + tickLength / 2, y, altScaleColour, 1);
        } else if (((y - origin.y) / unitLength) % drawnTicks === 0)
          myCanvas.drawLine(origin.x - tickLength / 2, y, origin.x + tickLength / 2, y, scaleColour, 1);
      }

      for (let y = origin.y - unitLength; y > 0; y -= unitLength) { // positive
        if ((y - origin.y) % (unitLength * scaleInterval) == 0 && y !== origin.y) {
          if (showScaleNumbers)
            myCanvas.drawText(-(y - origin.y) / unitLength, origin.x + tickLength * 2, y + 4, "black", true, 14, "bold");
          myCanvas.drawLine(origin.x - tickLength / 2, y, origin.x + tickLength / 2, y, altScaleColour, 1);
        } else if (((y - origin.y) / unitLength) % drawnTicks === 0)
          myCanvas.drawLine(origin.x - tickLength / 2, y, origin.x + tickLength / 2, y, scaleColour, 1);
      }

      // z axis 

      // where z is iterator

      for (let z = 1; z < (myCanvas.canvas.width / Math.cos(zAxis.angle) / 2) / unitLength; z++) { // negative (looks to be in q1)
        let zScalePoint = { x: (unitLength) * Math.cos(zAxis.angle), y: (unitLength) * Math.sin(zAxis.angle) };

        if (z % drawnTicks !== 0) // only draw certain ticks
          continue;

        let c = scaleColour;
        if (z % scaleInterval == 0) // make bold
          c = altScaleColour;


        myCanvas.drawLine(origin.x + z * zScalePoint.x - ((tickLength / 2) * Math.sin(zAxis.angle)),
          origin.y - z * zScalePoint.y - ((tickLength / 2) * Math.cos(zAxis.angle)),
          origin.x + z * zScalePoint.x + ((tickLength / 2) * Math.sin(zAxis.angle)),
          origin.y - z * zScalePoint.y + ((tickLength / 2) * Math.cos(zAxis.angle)), c, 1); // scale marker
      }

      for (let z = -1; z > (-myCanvas.canvas.width / Math.cos(zAxis.angle) / 2) / unitLength; z--) { // positive (looks to be in q3)
        let zScalePoint = { x: (unitLength) * Math.cos(zAxis.angle), y: (unitLength) * Math.sin(zAxis.angle) };

        if (z % drawnTicks !== 0) // only draw certain ticks
          continue;

        let c = scaleColour;
        if (z % scaleInterval == 0)
          c = altScaleColour;


        myCanvas.drawLine(origin.x + z * zScalePoint.x - ((tickLength / 2) * Math.sin(zAxis.angle)),
          origin.y - z * zScalePoint.y - ((tickLength / 2) * Math.cos(zAxis.angle)),
          origin.x + z * zScalePoint.x + ((tickLength / 2) * Math.sin(zAxis.angle)),
          origin.y - z * zScalePoint.y + ((tickLength / 2) * Math.cos(zAxis.angle)), c, 1); // scale marker
      }

    }

    /**
     * Gets the dot product of two vectors
     * 
     * @param {Vector} a The first vector to multiply
     * @param {Vector} b The second vector to multiply
     */

    function getDotProduct(a, b) {
      let x = a.components.x * b.components.x;
      let y = a.components.y * b.components.y;
      let z = a.components.z * b.components.z;

      return x + y + z;
    }

    /**
     * Gets the scalar projection of a on b
     * @param {Vector} a Vector a
     * @param {Vector} b Vector b
     */

    function getScalarProjection(a, b) {
      return Math.abs(getDotProduct(a, b) / b.magnitude);
    }

    /**
     * Gets the cross product of two vectors, then adds it to the vectors array
     * 
     * @param {Vector} a The first vector to multiply
     * @param {Vector} b The second vector to multiply
     * 
     * @returns {Vector} The cross product of a and b
     */

    function makeCrossProduct(a, b, createVector) {
      let x = a.components.y * b.components.z - a.components.z * b.components.y;
      let y = a.components.z * b.components.x - a.components.x * b.components.z;
      let z = a.components.x * b.components.y - a.components.y * b.components.x;

      if (createVector)
        return newVector(0, 0, 0, x, y, z);
      else
        return new Vector(0, 0, 0, x, y, z, "#000000", 1);
    }

    /**
     * Gets the vector projection of a on b, then adds it to the vectors array
     * @param {Vector} a Vector a
     * @param {Vector} b Vector b
     */

    function makeVectorProjection(a, b) {
      let multiplier = Math.round((getScalarProjection(a, b) / b.magnitude) * 1000) / 1000;

      return newVector(0, 0, 0, b.components.x * multiplier, b.components.y * multiplier, b.components.z * multiplier);
    }


    /**
     * Collects input
     */

    function getIn() { }

    /**
     * Makes a Vector object and adds it to the vectors array
     */

    function newVector(x1, y1, z1, x2, y2, z2, colour, width) {
      if (colour == undefined)
        colour = COLOURS[infoTabs % COLOURS.length];

      vectors[vectors.length] = new Vector(x1, y1, z1, x2, y2, z2, colour, width);
      buildInfo(vectors[vectors.length - 1]);
    }

    /**
     * Clears, redraws the canvas
     */

    function redraw() {
      myCanvas.clear();

      let c = myCanvas;

      // draw axes

      c.drawLine(0, origin.y, c.canvas.width, origin.y, "#000000");
      c.drawLine(origin.x, 0, origin.x, c.canvas.height, "#000000");
      c.drawLine(0, origin.y + zAxis.components.y, myCanvas.canvas.width, origin.y - zAxis.components.y, "#000000"); // z axis
      drawScale();

      // draw vectors

      for (let i = 0; i < vectors.length; i++)
        vectors[i].draw();
    }

    function resizeCanvas() {
      console.log("canvas resizing");
      // canvas

      myCanvas.canvas.width = document.getElementById("main").getBoundingClientRect().width - document.getElementById("controls").getBoundingClientRect().width;
      myCanvas.canvas.height = document.body.clientHeight - 64;

      // controls

      document.getElementById("vectorTabs").style.maxHeight = document.getElementById("controls").getBoundingClientRect().height - document.getElementById("calculations").getBoundingClientRect().height - 50 - 25;

      // scale

      setScale(numTicks);
    }

    /**
     * Changes the size of the unitLength, then updates vector cosmetic locations accordingly
     * @param {*} newNumTicks 
     */

    function setScale(newNumTicks) { // cws
      if (newNumTicks < 1)
        return;

      unitLength = Math.round(myCanvas.canvas.width / newNumTicks);
      if (unitLength === 1) {
        unitLength = 2;
        console.log("zoom limit reached")
        return;
      }

      numTicks = newNumTicks;

      if (numTicks / drawnTicks > 60) // lowering number of ticks onscreen
        drawnTicks = Math.ceil(numTicks / 50);

      if (numTicks / drawnTicks < 40 && drawnTicks > 1) // lowering number of ticks onscreen
        drawnTicks = Math.floor(numTicks / 50);

      scaleInterval = drawnTicks * 5;

      for (v in vectors)
        vectors[v].setCosmetics();
    }

    /**
     * Makes a vector visible or invisible and changes its infoTab accordingly. 
     * 
     * @param {*} el the infoTab
     * @param {*} visible true if the vector is to be visible, false if not
     */

    function setVectorVisibility(el) {
      let vector;

      for (let i = 0; i < vectors.length; i++) { // finding corresponding vector
        if (vectors[i].infoTab == el.id.substring(7))
          vector = vectors[i]; // passed by reference
      }

      vector.isVisible = !vector.isVisible;

      if (vector.isVisible) {
        console.log("now visible");
        el.children[0].style.border = "2px solid" + vector.colour;
        el.children[0].style.backgroundColor = vector.colour;
      } else {
        console.log("now invisible");
        el.children[0].style.border = "2px solid " + vector.colour;
        el.children[0].style.backgroundColor = "";
      }

    }

    /**
     * Updates vector data based on user input
     */

    function updateVectors() {
      for (let i = 0; i < vectors.length; i++) {
        let tab = document.getElementById("infoTab" + vectors[i].infoTab);
        let data = tab.children[1].children[0].children;

        vectors[i].setComponents(data[0].value, data[1].value, data[2].value);
      }
    }

    /**
     * The Vector object
     * 
     * @param {*} x1 The x-coordinate of the vector's origin
     * @param {*} y1 The y-coordinate of the vector's origin
     * @param {*} z1 The z-coordinate of the vector's origin
     * @param {*} x2 The x-component of the vector
     * @param {*} y2 The y-component of the vector
     * @param {*} z2 The z-component of the vector
     * @param {*} colour The colour of the vector 
     * @param {*} width The line width of the vector
     */

    function Vector(x1, y1, z1, x2, y2, z2, colour, width) {
      this.origin = { x: x1, y: y1, z: z1 }; // origin of the vector
      this.components = { x: x2, y: y2, z: z2 }; // endpoint of the vector
      this.magnitude = Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2) + Math.pow(z2, 2));

      this.colour = colour;
      this.lineWidth = width;
      this.isVisible = true;

      this.angle2d;

      // visual coordinate setting

      this.setCosmetics = function () {
        let k = { // unit vector along the positive z axis, [0,0,1]
          x: -unitLength * Math.cos(zAxis.angle),
          y: unitLength * Math.sin(zAxis.angle)
        }

        this.cosmeticOrigin = {
          x: this.origin.x * unitLength + origin.x + (k.x * this.origin.z),
          y: -this.origin.y * unitLength + origin.y + (k.y * this.origin.z)
        }
        this.cosmeticComponents = { // visual placement of the vector on the [2] screen
          x: this.components.x * unitLength + origin.x + this.origin.x * unitLength + (k.x * this.components.z) - this.cosmeticOrigin.x,
          y: -this.components.y * unitLength + origin.y - this.origin.y * unitLength + (k.y * this.components.z) - this.cosmeticOrigin.y
        };

        this.angle2d = Math.atan(Math.abs((this.cosmeticComponents.y) / (this.cosmeticComponents.x))) * 180 / Math.PI; // [2] angle to x axis 

        if (this.cosmeticComponents.x > 0) {
          if (this.cosmeticComponents.y < 0) {
            this.angle2d = 90 - this.angle2d;
          } else {
            this.angle2d += 90;
          }
        } else {
          if (this.cosmeticComponents.y > 0) {
            this.angle2d = 270 - this.angle2d;
          } else {
            this.angle2d += 270;
          }
        }

        if (this.angle2d === Infinity) {
          if (this.cosmeticComponents.y > 0)
            this.angle2d = 0;
          else
            this.angle2d = 180;
        }
      }

      this.setCosmetics(); // called here

      this.infoTab = -1;

      this.draw = function () {
        if (!this.isVisible)
          return;
        myCanvas.drawLine(this.cosmeticOrigin.x, this.cosmeticOrigin.y, this.cosmeticOrigin.x + this.cosmeticComponents.x, this.cosmeticOrigin.y + this.cosmeticComponents.y, colour, width);
        drawArrow(this);
      }

      /**
       * Resets the components of the Vector with new data, then updates the cosmetics
       */

      this.setComponents = function (x, y, z) {
        this.components.x = x;
        this.components.y = y;
        this.components.z = z;
        this.magnitude = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
        this.setCosmetics();
      }
    }

    function Vector2D(x1, y1, x2, y2, colour, width) {
      return new Vector(x1, y1, 0, x2, y2, 0, colour, width);
    }

    init(true, true);

    // General

    {
      function betterCreateAttr(type, value) {
        var attr = document.createAttribute(type);
        attr.value = value;
        return attr;
      }

      function isClicked(x, y, w, h) {
        if (
          myCanvas.mouseX < x + w &&
          myCanvas.mouseY < y + h &&
          x < myCanvas.mouseX &&
          y < myCanvas.mouseY &&
          myCanvas.recentClick
        )
          return true;
        else return false;
      }

      function isHovering(x, y, w, h) {
        if (
          myCanvas.mouseX < x + w &&
          myCanvas.mouseY < y + h &&
          x < myCanvas.mouseX &&
          y < myCanvas.mouseY
        )
          return true;
        else return false;
      }

      function mouseDown() {
        myCanvas.isClicking = true;
        console.log("DOWN");
      }

      function mouseUp() {
        myCanvas.isClicking = false;
        console.log("UP");
      }

      /**
       * Logs something to the console on the program's first iterations
       * @param {*} content String of the console.log
       */

      function log(content) {
        if (consolesLogged)
          return;
        console.log(content);
      }

      function orEquals(a, b) {
        for (var i = 0; i < b.length; i++) {
          if (a === b[i]) {
            return true;
          }
        }
        return false;
      }

      /**
       * Calculates the value of a missing side or angle
       * 
       * @param {*} a 
       * @param {*} b 
       * @param {*} c 
       * @param {*} theta
       */

      function pythagorean(a, b, c) {
        if (a == null)
          return Math.sqrt(Math.pow(c, 2) - Math.pow(b, 2));
        else if (b == null)
          return Math.sqrt(Math.pow(c, 2) - Math.pow(a, 2));
        else if (c == null)
          return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
      }

      function switchToMobile() {
        document.getElementById("main").style.marginTop = 0;
        document.getElementById("canvasBox").style.paddingTop = 0;
        document.getElementById("header").style.paddingTop = 0;
        document.getElementById("header").style.backgroundColor =
          "rgba(0,0,200,0.5)";
      }

      /**
       * Converts an angle from degrees to radians
       * @param {*} degreeValue The angle in degrees
       */

      function toRadians(degreeValue) {
        return degreeValue * (Math.PI / 180);
      }
    }  
  </script>

</body>

</html>